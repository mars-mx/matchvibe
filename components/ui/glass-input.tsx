'use client';

import * as React from 'react';
import { cn } from '@/lib/utils';

/**
 * WARNING: INTENTIONAL "SPAGHETTI CODE" DUE TO CHROME'S AUTOCOMPLETE BEHAVIOR
 *
 * Chrome intentionally ignores autocomplete="off" as a design decision by their security team.
 * They believe users should have control over their password managers, not websites.
 *
 * Official Chromium Bug Reports:
 * - https://issues.chromium.org/issues/40093420 - "Autofill does not respect autocomplete='off'"
 * - https://crbug.com/914451 - Ongoing discussion since 2018
 *
 * Chrome's Position (from their security team):
 * "It is the security team's view that this is very important for user security by
 * allowing users to have unique and more complex passwords for websites."
 *
 * WHY THIS CODE IS COMPLEX:
 * 1. Random autocomplete values - Prevents browser from learning field patterns
 * 2. Dynamic field names - Browser can't associate saved data with consistent field names
 * 3. Multiple data attributes - Different password managers look for different signals
 * 4. Readonly manipulation - Prevents autofill on page load but allows user input
 * 5. Hidden input for form submission - Maintains form functionality despite the hacks
 *
 * This is a widespread problem in web development. After 10+ years of developer complaints,
 * Chrome maintains their position. The workarounds below are industry-standard hacks.
 *
 * For simpler use cases, you might get away with just autoComplete="new-password",
 * but for production apps where users repeatedly enter different values, this full
 * implementation is often necessary.
 *
 * Generated by Claude Code (Opus 4.1)
 */

interface GlassInputProps extends Omit<React.ComponentProps<'input'>, 'type' | 'autoComplete'> {
  prefix?: string;
  antiAutofill?: boolean;
  glassClassName?: string;
  autoComplete?: string;
}

function GlassInput({
  className,
  prefix,
  antiAutofill = true,
  glassClassName,
  name,
  value,
  defaultValue,
  onChange,
  onFocus,
  onBlur,
  autoComplete,
  ...props
}: GlassInputProps) {
  const [isFocused, setIsFocused] = React.useState(false);
  const [inputValue, setInputValue] = React.useState(() => {
    return String(value || defaultValue || '');
  });
  const [randomId] = React.useState(() => Math.random().toString(36).substring(7));
  const inputRef = React.useRef<HTMLInputElement>(null);

  // Generate random autocomplete value to prevent browser detection
  const autoCompleteValue = React.useMemo(() => {
    if (!antiAutofill) return undefined;
    return `search-${randomId}-${Date.now()}`;
  }, [antiAutofill, randomId]);

  // Dynamic name to prevent browser memory
  const fieldName = React.useMemo(() => {
    if (!antiAutofill) return name;
    return name || `field-${randomId}`;
  }, [antiAutofill, name, randomId]);

  const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {
    setIsFocused(true);
    if (antiAutofill && inputRef.current) {
      // Remove readonly on focus
      inputRef.current.removeAttribute('readonly');
    }
    onFocus?.(e);
  };

  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    setIsFocused(false);
    onBlur?.(e);
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(e.target.value);
    onChange?.(e);
  };

  // Sync value prop with internal state
  React.useEffect(() => {
    if (value !== undefined) {
      setInputValue(String(value));
    }
  }, [value]);

  React.useEffect(() => {
    // Set readonly initially, remove on mount to prevent autofill
    const timer = setTimeout(() => {
      if (antiAutofill && inputRef.current && !isFocused) {
        inputRef.current.removeAttribute('readonly');
      }
    }, 100);
    return () => clearTimeout(timer);
  }, [antiAutofill, isFocused]);

  return (
    <div
      className={cn(
        'liquid-glass relative flex min-h-[42px] flex-1 items-center overflow-hidden rounded-xl',
        glassClassName
      )}
      role="presentation"
    >
      <div className="liquid-glass-inner" />

      {prefix && (
        <span className="relative z-10 pr-1 pl-3 font-medium text-white/90 select-none">
          {prefix}
        </span>
      )}

      <input
        ref={inputRef}
        type="text"
        name={antiAutofill && name ? undefined : fieldName}
        className={cn(
          'relative z-10 h-full w-full border-0 bg-transparent text-white placeholder:text-white/30',
          'focus-visible:ring-0 focus-visible:ring-offset-0 focus-visible:outline-none',
          'px-3 py-1 text-[15px] font-medium tracking-wide',
          'selection:bg-primary/30 selection:text-white',
          className
        )}
        autoComplete={antiAutofill ? autoCompleteValue : autoComplete}
        autoCorrect={antiAutofill ? 'off' : props.autoCorrect}
        autoCapitalize={antiAutofill ? 'off' : props.autoCapitalize}
        spellCheck={antiAutofill ? false : props.spellCheck}
        data-form-type={antiAutofill ? 'other' : undefined}
        data-lpignore={antiAutofill ? 'true' : undefined}
        data-1p-ignore={antiAutofill ? true : undefined}
        inputMode="text"
        readOnly={antiAutofill ? true : props.readOnly}
        onFocus={handleFocus}
        onBlur={handleBlur}
        onChange={handleChange}
        value={inputValue}
        {...props}
      />

      {/* Hidden input to store actual value for form submission when using antiAutofill */}
      {antiAutofill && name && <input type="hidden" name={name} value={inputValue} readOnly />}
    </div>
  );
}

export { GlassInput };
